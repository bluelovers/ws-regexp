// Generated by dts-bundle v0.7.3

declare module 'regexpp2' {
    import AST = require("regexpp2/ast");
    import { RegExpParser } from "regexpp2/parser";
    import { RegExpValidator } from "regexpp2/validator";
    export { AST, RegExpParser, RegExpValidator };
    /**
        * Parse a given regular expression literal then make AST object.
        * @param source The source code to parse.
        * @param options The options to parse.
        * @returns The AST of the regular expression.
        */
    export function parseRegExpLiteral(source: string | RegExp, options?: RegExpParser.Options): AST.RegExpLiteral;
    /**
        * Validate a given regular expression literal.
        * @param source The source code to validate.
        * @param options The options to validate.
        */
    export function validateRegExpLiteral(source: string, options?: RegExpValidator.Options): void;
}

declare module 'regexpp2/ast' {
    /**
        * The type which includes all nodes.
        */
    export type Node = BranchNode | LeafNode;
    /**
        * The type which includes all branch nodes.
        */
    export type BranchNode = RegExpLiteral | Pattern | Disjunction | Group | CapturingGroup | Quantifier | CharacterClass | LookaroundAssertion | CharacterClassRange;
    /**
        * The type which includes all leaf nodes.
        */
    export type LeafNode = BoundaryAssertion | CharacterSet | Character | Backreference | Flags;
    /**
        * The type which includes all atom nodes.
        */
    export type Element = Disjunction | Group | CapturingGroup | Quantifier | CharacterClass | Assertion | CharacterSet | Character | Backreference;
    /**
        * The type which includes all character class atom nodes.
        */
    export type CharacterClassElement = EscapeCharacterSet | UnicodePropertyCharacterSet | Character | CharacterClassRange;
    /**
        * The type which includes all atom nodes that Alternative node can have as children.
        */
    export type AlternativeElement = Group | CapturingGroup | Quantifier | CharacterClass | Assertion | CharacterSet | Character | Backreference;
    /**
        * The type which includes all atom nodes that Quantifier node can have as children.
        */
    export type QuantifiableElement = Group | CapturingGroup | CharacterClass | LookaheadAssertion | CharacterSet | Character | Backreference;
    /**
        * The type which defines common properties for all node types.
        */
    export interface NodeBase {
            /** The node type. */
            type: Node["type"];
            /** The parent node. */
            parent: Node["parent"];
            /** The 0-based index that this node starts. */
            start: number;
            /** The 0-based index that this node ends. */
            end: number;
            /** The raw text of this node. */
            raw: string;
    }
    /**
        * The root node.
        */
    export interface RegExpLiteral extends NodeBase {
            type: "RegExpLiteral";
            parent: null;
            pattern: Pattern;
            flags: Flags;
    }
    /**
        * The pattern.
        */
    export interface Pattern extends NodeBase {
            type: "Pattern";
            parent: RegExpLiteral | null;
            elements: Element[];
    }
    /**
        * The disjunction.
        * E.g. `a|b`
        */
    export interface Disjunction extends NodeBase {
            type: "Disjunction";
            parent: Pattern | Group | CapturingGroup | LookaroundAssertion;
            alternatives: AlternativeElement[][];
    }
    /**
        * The uncapturing group.
        * E.g. `(?:ab)`
        */
    export interface Group extends NodeBase {
            type: "Group";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            elements: Element[];
    }
    /**
        * The capturing group.
        * E.g. `(ab)`, `(?<name>ab)`
        */
    export interface CapturingGroup extends NodeBase {
            type: "CapturingGroup";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            name: string | null;
            elements: Element[];
            references: Backreference[];
    }
    /**
        * The lookaround assertion.
        */
    export type LookaroundAssertion = LookaheadAssertion | LookbehindAssertion;
    /**
        * The lookahead assertion.
        * E.g. `(?=ab)`, `(?!ab)`
        */
    export interface LookaheadAssertion extends NodeBase {
            type: "Assertion";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            kind: "lookahead";
            negate: boolean;
            elements: Element[];
    }
    /**
        * The lookbehind assertion.
        * E.g. `(?<=ab)`, `(?<!ab)`
        */
    export interface LookbehindAssertion extends NodeBase {
            type: "Assertion";
            parent: Pattern | Disjunction | Group | CapturingGroup | LookaroundAssertion;
            kind: "lookbehind";
            negate: boolean;
            elements: Element[];
    }
    /**
        * The quantifier.
        * E.g. `a?`, `a*`, `a+`, `a{1,2}`, `a??`, `a*?`, `a+?`, `a{1,2}?`
        */
    export interface Quantifier extends NodeBase {
            type: "Quantifier";
            parent: Pattern | Disjunction | Group | CapturingGroup | LookaroundAssertion;
            min: number;
            max: number;
            greedy: boolean;
            element: QuantifiableElement;
    }
    /**
        * The character class.
        * E.g. `[ab]`, `[^ab]`
        */
    export interface CharacterClass extends NodeBase {
            type: "CharacterClass";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            negate: boolean;
            elements: CharacterClassElement[];
    }
    /**
        * The character class.
        * E.g. `[a-b]`
        */
    export interface CharacterClassRange extends NodeBase {
            type: "CharacterClassRange";
            parent: CharacterClass;
            min: Character;
            max: Character;
    }
    /**
        * The assertion.
        */
    export type Assertion = BoundaryAssertion | LookaroundAssertion;
    /**
        * The boundary assertion.
        */
    export type BoundaryAssertion = EdgeAssertion | WordBoundaryAssertion;
    /**
        * The edge boundary assertion.
        * E.g. `^`, `$`
        */
    export interface EdgeAssertion extends NodeBase {
            type: "Assertion";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            kind: "start" | "end";
    }
    /**
        * The word bondary assertion.
        * E.g. `\b`, `\B`
        */
    export interface WordBoundaryAssertion extends NodeBase {
            type: "Assertion";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            kind: "word";
            negate: boolean;
    }
    /**
        * The character set.
        */
    export type CharacterSet = AnyCharacterSet | EscapeCharacterSet | UnicodePropertyCharacterSet;
    /**
        * The dot.
        * E.g. `.`
        */
    export interface AnyCharacterSet extends NodeBase {
            type: "CharacterSet";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            kind: "any";
    }
    /**
        * The character class escape.
        * E.g. `\d`, `\s`, `\w`, `\D`, `\S`, `\W`
        */
    export interface EscapeCharacterSet extends NodeBase {
            type: "CharacterSet";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | CharacterClass | LookaroundAssertion;
            kind: "digit" | "space" | "word";
            negate: boolean;
    }
    /**
        * The unicode property escape.
        * E.g. `\p{ASCII}`, `\P{ASCII}`, `\p{Script=Hiragana}`
        */
    export interface UnicodePropertyCharacterSet extends NodeBase {
            type: "CharacterSet";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | CharacterClass | LookaroundAssertion;
            kind: "property";
            key: string;
            value: string | null;
            negate: boolean;
    }
    /**
        * The character.
        * This includes escape sequences which mean a character.
        * E.g. `a`, `あ`, `✿`, `\x65`, `\u0065`, `\u{65}`, `\/`
        */
    export interface Character extends NodeBase {
            type: "Character";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | CharacterClass | LookaroundAssertion | CharacterClassRange;
            value: number;
    }
    /**
        * The backreference.
        * E.g. `\1`, `\k<name>`
        */
    export interface Backreference extends NodeBase {
            type: "Backreference";
            parent: Pattern | Disjunction | Group | CapturingGroup | Quantifier | LookaroundAssertion;
            ref: number | string;
            resolved: CapturingGroup;
    }
    /**
        * The flags.
        */
    export interface Flags extends NodeBase {
            type: "Flags";
            parent: RegExpLiteral | null;
            dotAll: boolean;
            global: boolean;
            ignoreCase: boolean;
            multiline: boolean;
            sticky: boolean;
            unicode: boolean;
    }
}

declare module 'regexpp2/parser' {
    import { Flags, RegExpLiteral, Pattern } from "regexpp2/ast";
    export namespace RegExpParser {
            /**
                * The options for RegExpParser construction.
                */
            interface Options {
                    /**
                        * The flag to disable Annex B syntax. Default is `false`.
                        */
                    strict?: boolean;
                    /**
                        * ECMAScript version. Default is `2018`.
                        * - `2015` added `u` and `y` flags.
                        * - `2018` added `s` flag, Named Capturing Group, Lookbehind Assertion,
                        *   and Unicode Property Escape.
                        */
                    ecmaVersion?: 5 | 2015 | 2016 | 2017 | 2018;
                    disableChkCharacterClassRange?: boolean;
            }
    }
    export class RegExpParser {
            /**
                * Initialize this parser.
                * @param options The options of parser.
                */
            constructor(options?: RegExpParser.Options);
            /**
                * Parse a regular expression literal. E.g. "/abc/g"
                * @param source The source code to parse.
                * @param start The start index in the source code.
                * @param end The end index in the source code.
                * @returns The AST of the given regular expression.
                */
            parseLiteral(source: string, start?: number, end?: number): RegExpLiteral;
            /**
                * Parse a regular expression flags. E.g. "gim"
                * @param source The source code to parse.
                * @param start The start index in the source code.
                * @param end The end index in the source code.
                * @returns The AST of the given flags.
                */
            parseFlags(source: string, start?: number, end?: number): Flags;
            /**
                * Parse a regular expression pattern. E.g. "abc"
                * @param source The source code to parse.
                * @param start The start index in the source code.
                * @param end The end index in the source code.
                * @param uFlag The flag to set unicode mode.
                * @returns The AST of the given pattern.
                */
            parsePattern(source: string, start?: number, end?: number, uFlag?: boolean): Pattern;
    }
}

declare module 'regexpp2/validator' {
    export namespace RegExpValidator {
            /**
                * The options for RegExpValidator construction.
                */
            interface Options {
                    /**
                        * The flag to disable Annex B syntax. Default is `false`.
                        */
                    strict?: boolean;
                    /**
                        * ECMAScript version. Default is `2018`.
                        * - `2015` added `u` and `y` flags.
                        * - `2018` added `s` flag, Named Capturing Group, Lookbehind Assertion,
                        *   and Unicode Property Escape.
                        */
                    ecmaVersion?: 5 | 2015 | 2016 | 2017 | 2018;
                    disableChkCharacterClassRange?: boolean;
                    /**
                        * A function that is called when the validator entered a RegExp literal.
                        * @param start The 0-based index of the first character.
                        */
                    onLiteralEnter?(start: number): void;
                    /**
                        * A function that is called when the validator left a RegExp literal.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        */
                    onLiteralLeave?(start: number, end: number): void;
                    /**
                        * A function that is called when the validator found flags.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param global `g` flag.
                        * @param ignoreCase `i` flag.
                        * @param multiline `m` flag.
                        * @param unicode `u` flag.
                        * @param sticky `y` flag.
                        * @param dotAll `s` flag.
                        */
                    onFlags?(start: number, end: number, global: boolean, ignoreCase: boolean, multiline: boolean, unicode: boolean, sticky: boolean, dotAll: boolean): void;
                    /**
                        * A function that is called when the validator entered a pattern.
                        * @param start The 0-based index of the first character.
                        */
                    onPatternEnter?(start: number): void;
                    /**
                        * A function that is called when the validator left a pattern.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        */
                    onPatternLeave?(start: number, end: number): void;
                    /**
                        * A function that is called when the validator entered a disjunction.
                        * @param start The 0-based index of the first character.
                        */
                    onDisjunctionEnter?(start: number): void;
                    /**
                        * A function that is called when the validator left a disjunction.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        */
                    onDisjunctionLeave?(start: number, end: number): void;
                    /**
                        * A function that is called when the validator entered an alternative.
                        * @param start The 0-based index of the first character.
                        * @param index The 0-based index of alternatives in a disjunction.
                        */
                    onAlternativeEnter?(start: number, index: number): void;
                    /**
                        * A function that is called when the validator left an alternative.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param index The 0-based index of alternatives in a disjunction.
                        */
                    onAlternativeLeave?(start: number, end: number, index: number): void;
                    /**
                        * A function that is called when the validator entered an uncapturing group.
                        * @param start The 0-based index of the first character.
                        */
                    onGroupEnter?(start: number): void;
                    /**
                        * A function that is called when the validator left an uncapturing group.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        */
                    onGroupLeave?(start: number, end: number): void;
                    /**
                        * A function that is called when the validator entered a capturing group.
                        * @param start The 0-based index of the first character.
                        * @param name The group name.
                        */
                    onCapturingGroupEnter?(start: number, name: string | null): void;
                    /**
                        * A function that is called when the validator left a capturing group.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param name The group name.
                        */
                    onCapturingGroupLeave?(start: number, end: number, name: string | null): void;
                    /**
                        * A function that is called when the validator found a quantifier.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param min The minimum number of repeating.
                        * @param max The maximum number of repeating.
                        * @param greedy The flag to choose the longest matching.
                        */
                    onQuantifier?(start: number, end: number, min: number, max: number, greedy: boolean): void;
                    /**
                        * A function that is called when the validator entered a lookahead/lookbehind assertion.
                        * @param start The 0-based index of the first character.
                        * @param kind The kind of the assertion.
                        * @param negate The flag which represents that the assertion is negative.
                        */
                    onLookaroundAssertionEnter?(start: number, kind: "lookahead" | "lookbehind", negate: boolean): void;
                    /**
                        * A function that is called when the validator left a lookahead/lookbehind assertion.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param kind The kind of the assertion.
                        * @param negate The flag which represents that the assertion is negative.
                        */
                    onLookaroundAssertionLeave?(start: number, end: number, kind: "lookahead" | "lookbehind", negate: boolean): void;
                    /**
                        * A function that is called when the validator found an edge boundary assertion.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param kind The kind of the assertion.
                        */
                    onEdgeAssertion?(start: number, end: number, kind: "start" | "end"): void;
                    /**
                        * A function that is called when the validator found a word boundary assertion.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param kind The kind of the assertion.
                        * @param negate The flag which represents that the assertion is negative.
                        */
                    onWordBoundaryAssertion?(start: number, end: number, kind: "word", negate: boolean): void;
                    /**
                        * A function that is called when the validator found a dot.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param kind The kind of the character set.
                        */
                    onAnyCharacterSet?(start: number, end: number, kind: "any"): void;
                    /**
                        * A function that is called when the validator found a character set escape.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param kind The kind of the character set.
                        * @param negate The flag which represents that the character set is negative.
                        */
                    onEscapeCharacterSet?(start: number, end: number, kind: "digit" | "space" | "word", negate: boolean): void;
                    /**
                        * A function that is called when the validator found a Unicode proerty escape.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param kind The kind of the character set.
                        * @param key The property name.
                        * @param value The property value.
                        * @param negate The flag which represents that the character set is negative.
                        */
                    onUnicodePropertyCharacterSet?(start: number, end: number, kind: "property", key: string, value: string | null, negate: boolean): void;
                    /**
                        * A function that is called when the validator found a character.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param value The code point of the character.
                        */
                    onCharacter?(start: number, end: number, value: number): void;
                    /**
                        * A function that is called when the validator found a backreference.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param ref The key of the referred capturing group.
                        */
                    onBackreference?(start: number, end: number, ref: number | string): void;
                    /**
                        * A function that is called when the validator entered a character class.
                        * @param start The 0-based index of the first character.
                        * @param negate The flag which represents that the character class is negative.
                        */
                    onCharacterClassEnter?(start: number, negate: boolean): void;
                    /**
                        * A function that is called when the validator left a character class.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param negate The flag which represents that the character class is negative.
                        */
                    onCharacterClassLeave?(start: number, end: number, negate: boolean): void;
                    /**
                        * A function that is called when the validator found a character class range.
                        * @param start The 0-based index of the first character.
                        * @param end The next 0-based index of the last character.
                        * @param min The minimum code point of the range.
                        * @param max The maximum code point of the range.
                        */
                    onCharacterClassRange?(start: number, end: number, min: number, max: number): void;
            }
    }
    /**
        * The regular expression validator.
        */
    export class RegExpValidator {
            /**
                * Initialize this validator.
                * @param options The options of validator.
                */
            constructor(options?: RegExpValidator.Options);
            /**
                * Validate a regular expression literal. E.g. "/abc/g"
                * @param source The source code to validate.
                * @param start The start index in the source code.
                * @param end The end index in the source code.
                */
            validateLiteral(source: string, start?: number, end?: number): void;
            /**
                * Validate a regular expression flags. E.g. "gim"
                * @param source The source code to validate.
                * @param start The start index in the source code.
                * @param end The end index in the source code.
                */
            validateFlags(source: string, start?: number, end?: number): void;
            /**
                * Validate a regular expression pattern. E.g. "abc"
                * @param source The source code to validate.
                * @param start The start index in the source code.
                * @param end The end index in the source code.
                * @param uFlag The flag to set unicode mode.
                */
            validatePattern(source: string, start?: number, end?: number, uFlag?: boolean): void;
    }
}

